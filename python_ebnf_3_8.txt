root ::= (NEWLINE | stmt)*

decorator ::= "@" dotted_name ( "(" arglist? ")" )? NEWLINE
decorators ::= decorator+
decorated ::= decorators (classdef | funcdef | async_funcdef)

async_funcdef ::= "async" MUST_WB funcdef
funcdef ::= "def" MUST_WB NAME parameters ("->" test)? ":" TYPE_COMMENT? func_body_suite

parameters ::= "(" typedargslist? ")"

typedargslist ::= (
  (tfpdef ((WB "=" WB) test)? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (WB "," WB) TYPE_COMMENT? "/" ((WB "," WB) ( TYPE_COMMENT? tfpdef ((WB "=" WB) test)? (
        (WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? (
        "*" tfpdef? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? ("**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
      | "**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
  | "*" tfpdef? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? ("**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
  | "**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
|  (tfpdef ((WB "=" WB) test)? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? (
   "*" tfpdef? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? ("**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
  | "**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
  | "*" tfpdef? ((WB "," WB) TYPE_COMMENT? tfpdef ((WB "=" WB) test)?)* (TYPE_COMMENT | ((WB "," WB) TYPE_COMMENT? ("**" tfpdef (WB "," WB)? TYPE_COMMENT?)?)?)
  | "**" tfpdef (WB "," WB)? TYPE_COMMENT?)
)
tfpdef ::= NAME (":" test)?

varargslist ::= vfpdef ((WB "=" WB) test )?((WB "," WB) vfpdef ((WB "=" WB) test)?)* (WB "," WB) "/" ((WB "," WB) ( (vfpdef ((WB "=" WB) test)? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) (
        "*" vfpdef? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) ("**" vfpdef (WB "," WB)?)?)?
      | "**" vfpdef (WB "," WB)?)?)?
  | "*" vfpdef? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) ("**" vfpdef (WB "," WB)?)?)?
  | "**" vfpdef (WB "," WB)?) )?)? | (vfpdef ((WB "=" WB) test)? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) (
        "*" vfpdef? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) ("**" vfpdef (WB "," WB)?)?)?
      | "**" vfpdef (WB "," WB)?)?)?
  | "*" vfpdef? ((WB "," WB) vfpdef ((WB "=" WB) test)?)* ((WB "," WB) ("**" vfpdef (WB "," WB)?)?)?
  | "**" vfpdef (WB "," WB)?
)
vfpdef ::= NAME

stmt ::= simple_stmt | compound_stmt
simple_stmt ::= small_stmt (";" small_stmt)* ";"? NEWLINE
small_stmt ::= (expr_stmt | del_stmt | pass_stmt | flow_stmt |
             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
expr_stmt ::= testlist_star_expr (annassign | WB augassign WB (yield_expr|testlist) |
                     (((WB "=" WB) (yield_expr|testlist_star_expr))+ TYPE_COMMENT?)? )
annassign ::= ":" test ((WB "=" WB) (yield_expr|testlist_star_expr))?
testlist_star_expr ::= (test|star_expr) ((WB "," WB) (test|star_expr))* (WB "," WB)?
augassign ::= ("+=" | "-=" | "*=" | "@=" | "/=" | "%=" | "&=" | "|=" | "^=" |
            "<<=" | ">>=" | "**=" | "//=")


del_stmt ::= "del" MUST_WB exprlist
pass_stmt ::= "pass"
flow_stmt ::= break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
break_stmt ::= "break"
continue_stmt ::= "continue"
return_stmt ::= "return" (MUST_WB testlist_star_expr)?
yield_stmt ::= yield_expr
raise_stmt ::= "raise" (MUST_WB test ("from" MUST_WB test)?)?
import_stmt ::= import_name | import_from
import_name ::= "import" MUST_WB dotted_as_names

import_from ::= ("from" MUST_WB (("." | "...")* dotted_name | ("." | "...")+)
              "import" MUST_WB ("*" | "(" import_as_names ")" | import_as_names))
import_as_name ::= NAME (MUST_WB "as" MUST_WB NAME)?
dotted_as_name ::= dotted_name (MUST_WB "as" MUST_WB NAME)?
import_as_names ::= import_as_name ((WB "," WB) import_as_name)* (WB "," WB)?
dotted_as_names ::= dotted_as_name ((WB "," WB) dotted_as_name)*
dotted_name ::= NAME ("." NAME)*
global_stmt ::= "global" MUST_WB NAME ((WB "," WB) NAME)*
nonlocal_stmt ::= "nonlocal" MUST_WB NAME ((WB "," WB) NAME)*
assert_stmt ::= "assert" MUST_WB test ((WB "," WB) test)?

compound_stmt ::= if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
async_stmt ::= "async" MUST_WB (funcdef | with_stmt | for_stmt)
if_stmt ::= "if" MUST_WB namedexpr_test ":" suite ("elif" MUST_WB namedexpr_test ":" suite)* ("else" ":" suite)?
while_stmt ::= "while" MUST_WB namedexpr_test ":" suite (MUST_WB "else" ":" suite)?
for_stmt ::= "for" MUST_WB exprlist MUST_WB "in" MUST_WB testlist ":" TYPE_COMMENT? suite ("else" ":" suite)?
try_stmt ::= ("try" ":" suite
           ((except_clause ":" suite)+
            ("else" ":" suite)?
            ("finally" ":" suite)? |
           "finally" ":" suite))
with_stmt ::= "with" MUST_WB with_item ((WB "," WB) with_item)*  ":" TYPE_COMMENT? suite
with_item ::= test (MUST_WB "as" MUST_WB expr)?

except_clause ::= "except" (MUST_WB test (MUST_WB "as" MUST_WB NAME)?)?
suite ::= simple_stmt | NEWLINE INDENT stmt+ DEDENT

namedexpr_test ::= test (":=" test)?
test ::= or_test ("if" MUST_WB or_test MUST_WB "else" MUST_WB test)? | lambdef
test_nocond ::= or_test | lambdef_nocond
lambdef ::= "lambda" (MUST_WB varargslist)? ":" test
lambdef_nocond ::= "lambda" (MUST_WB varargslist)? ":" test_nocond
or_test ::= and_test (MUST_WB "or" MUST_WB and_test)*
and_test ::= not_test (MUST_WB "and" MUST_WB not_test)*
not_test ::= MUST_WB "not" MUST_WB not_test | comparison
comparison ::= expr (WB comp_op WB expr)*


comp_op ::= "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"not" "in"|"is"|"is" "not"
star_expr ::= WB "*" WB expr
expr ::= xor_expr (WB "|" WB xor_expr)*
xor_expr ::= and_expr (WB "^" WB and_expr)*
and_expr ::= shift_expr (WB"&" WB shift_expr)*
shift_expr ::= arith_expr (WB ("<<"|">>") WB arith_expr)*
arith_expr ::= term (WB ("+"|"-") WB term)*
term ::= factor (WB ("*"|"@"|"/"|"%"|"//") WB factor)*
factor ::= WB ("+"|"-"|"~") WB factor | power
power ::= atom_expr (WB "**" WB factor)?
atom_expr ::= "await"? atom trailer*
atom ::= ("(" (yield_expr|testlist_comp)? ")" |
       "[" testlist_comp? "]" |
       "{" dictorsetmaker? "}" |
       NAME | NUMBER | STRING+ | "..." | "None" | "True" | "False")
testlist_comp ::= (namedexpr_test|star_expr) ( comp_for | ((WB "," WB) (namedexpr_test|star_expr))* (WB "," WB)? )
trailer ::= "(" arglist? ")" | "[" subscriptlist "]" | "." NAME
subscriptlist ::= subscript ((WB "," WB) subscript)* (WB "," WB)?
subscript ::= test | test? ":" test? sliceop?
sliceop ::= ":" test?
exprlist ::= (expr|star_expr) ((WB "," WB) (expr|star_expr))* (WB "," WB)?
testlist ::= test ((WB "," WB) test)* (WB "," WB)?
dictorsetmaker ::= ( ((test ":" test | "**" expr)
                   (comp_for | ((WB "," WB) (test ":" test | "**" expr))* (WB "," WB)?)) |
                  ((test | star_expr)
                   (comp_for | ((WB "," WB) (test | star_expr))* (WB "," WB)?)) )

classdef ::= "class" MUST_WB NAME ("(" arglist? ")")? ":" suite

arglist ::= argument ((WB "," WB) argument)*  (WB "," WB)?

argument ::= ( test comp_for? |
            test ":=" test |
            test (WB "=" WB) test |
            "**" test |
            "*" test )

comp_iter ::= comp_for | comp_if
sync_comp_for ::= "for" MUST_WB exprlist MUST_WB "in" MUST_WB or_test comp_iter?
comp_for ::= "async" MUST_WB sync_comp_for | sync_comp_for
comp_if ::= "if" MUST_WB test_nocond comp_iter?

yield_expr ::= "yield" MUST_WB yield_arg?
yield_arg ::= "from" MUST_WB test | testlist_star_expr

func_body_suite ::= simple_stmt | NEWLINE (TYPE_COMMENT NEWLINE)? INDENT stmt+ DEDENT


typelist ::= (test ((WB "," WB) test)* ((WB "," WB)
       ("*" test? ((WB "," WB) test)* ((WB "," WB) "**" test)? | "**" test)?)?
     |  "*" test? ((WB "," WB) test)* ((WB "," WB) "**" test)? | "**" test)

stringliteral   ::=  stringprefix? (shortstring | longstring)
stringprefix    ::=  "r" | "u" | "R" | "U" | "f" | "F"
                     | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
shortstring     ::=  "'" shortstringitem* "'" | "\"" shortstringitem* "\""
longstring      ::=  "'''" longstringitem* "'''" | "\"\"\"" longstringitem* "\"\"\""
shortstringitem ::=  shortstringchar | stringescapeseq
longstringitem  ::=  longstringchar | stringescapeseq
shortstringchar ::=  [^\\\"\r\n]
longstringchar  ::=  [^\\]
stringescapeseq ::=  "\\" [\0-\xff]

bytesliteral   ::=  bytesprefix(shortbytes | longbytes)
bytesprefix    ::=  "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
shortbytes     ::=  "'" shortbytesitem* "'" | "\"" shortbytesitem* "\""
longbytes      ::=  "'''" longbytesitem* "'''" | "\"\"\"" longbytesitem* "\"\"\""
shortbytesitem ::=  shortbyteschar | bytesescapeseq
longbytesitem  ::=  longbyteschar | bytesescapeseq
shortbyteschar ::=  [^\\\"\r\n]
longbyteschar  ::=  [^\\]
bytesescapeseq ::=  "\\" [\0-\x7f]

f_string          ::=  "f\"" (literal_char | "{{" | "}}" | replacement_field)* "\""
replacement_field ::=  "{" f_expression (WB "=" WB)? ("!" conversion)? (":" format_spec)? "}"
f_expression      ::=  (conditional_expression | "*" xor_expr)
                         ((WB "," WB) conditional_expression | (WB "," WB) "*" xor_expr)* (WB "," WB)?
                       | yield_expr
conversion        ::=  "s" | "r" | "a"
format_spec       ::=  (literal_char | "\0" | replacement_field)*
literal_char      ::=  [^{}\0]
conditional_expression ::= expr MUST_WB "if" MUST_WB expr MUST_WB "else" MUST_WB expr

integer      ::=  decinteger | bininteger | octinteger | hexinteger
decinteger   ::=  nonzerodigit ("_"? digit)* | "0"+ ("_"? "0")*
bininteger   ::=  "0" ("b" | "B") ("_"? bindigit)+
octinteger   ::=  "0" ("o" | "O") ("_"? octdigit)+
hexinteger   ::=  "0" ("x" | "X") ("_"? hexdigit)+
nonzerodigit ::=  [1-9]
digit        ::=  [0-9]
bindigit     ::=  [0-1]
octdigit     ::=  [0-7]
hexdigit     ::=  [0-9a-fA-F]

floatnumber   ::=  pointfloat | exponentfloat
pointfloat    ::=  digitpart? fraction | digitpart "."
exponentfloat ::=  (digitpart | pointfloat) exponent
digitpart     ::=  digit ("_"? digit)*
fraction      ::=  "." digitpart
exponent      ::=  ("e" | "E") ("+" | "-")? digitpart
imagnumber ::=  (floatnumber | digitpart) ("j" | "J")

NEWLINE ::= [\r\n]
NAME ::= [a-zA-Z_][a-zA-Z_0-9]*
TYPE_COMMENT ::= "#" "type" ":" [^\r\n]*
INDENT ::= "<INDENT>"
DEDENT ::= "<DEDENT>"
NUMBER ::= integer | floatnumber | imagnumber
STRING ::= stringliteral | bytesliteral | f_string
WB ::= [ ]*
MUST_WB ::= [ ]+
